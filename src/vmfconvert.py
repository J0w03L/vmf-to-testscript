"""
    VMF to TestScript for Xbox 360
    -------------------------------------------
    https://github.com/J0w03L/vmf-to-testscript
    https://j0w03l.me
    -------------------------------------------
"""

from PyVMF import *

class TestScript:
    def __init__(self, vmfPath: str, outPath: str, startID: int):
        self.vmfPath = vmfPath
        self.vmf     = load_vmf(vmfPath)
        self.ents    = self.__getents__()
        
        self.__genscript__(outPath, startID)
    
    def __getents__(self):
        ret = {}

        for entIdx, ent in enumerate(self.vmf.get_entities(include_solid_entities = True)):
            ret[entIdx] = {
                "hammerid":    ent.id,
                "classname":   ent.classname,
                "properties":  {str(key): str(value) for key, value in ent.other.items()},
                "connections": [],
                "solids": ent.solids
            }

            if len(ent.connections) != 0:
                for conIdx, con in enumerate(ent.connections):
                    con = con.other
                    for key, value in con.items():
                        ret[entIdx]["connections"].append(
                            {
                                "event":  key,
                                "target": value.split("\x1b")[0],
                                "input":  value.split("\x1b")[1],
                                "args":   value.split("\x1b")[2],
                                "delay":  value.split("\x1b")[3]
                            }
                        )

            if len(ent.solids) != 0:
                sides = ent.solids[0].get_sides()

                # This assumes that the brush is a cube/rectangle. I don't think it matters because we can't do anything more complex in a testscript anyway.
                origin = [
                    str(round(((sides[0].get_vertices()[2].x - sides[1].get_vertices()[0].x) / 2) + sides[1].get_vertices()[0].x, 3)),
                    str(round(((sides[0].get_vertices()[1].y - sides[1].get_vertices()[0].y) / 2) + sides[1].get_vertices()[0].y, 3)),
                    str(round(((sides[0].get_vertices()[0].z - sides[1].get_vertices()[0].z) / 2) + sides[1].get_vertices()[0].z, 3))
                ]

                ret[entIdx]["properties"]["origin"] = " ".join(origin)

                mins = [
                    round((sides[0].get_vertices()[0].x - sides[1].get_vertices()[2].x) / 2, 3),
                    round((sides[0].get_vertices()[1].y - sides[1].get_vertices()[1].y) / 2, 3),
                    round((sides[0].get_vertices()[2].z - sides[1].get_vertices()[0].z) / 2, 3)
                ]

                if mins[0] < 0.0: mins[0] = -mins[0]
                if mins[1] < 0.0: mins[1] = -mins[1]
                if mins[2] < 0.0: mins[2] = -mins[2]

                maxs = [-mins[0], -mins[1], -mins[2]]

                mins[0] = str(mins[0])
                mins[1] = str(mins[1])
                mins[2] = str(mins[2])

                maxs[0] = str(maxs[0])
                maxs[1] = str(maxs[1])
                maxs[2] = str(maxs[2])

                ret[entIdx]["properties"]["mins"] = " ".join(mins)
                ret[entIdx]["properties"]["maxs"] = " ".join(maxs)
        
        return ret
    
    def __genscript__(self, outPath: str, startID: int):
        out = open(outPath, "w")

        # Write header comment
        out.write("// This file was automatically generated by VMF-to-TestScript. //\n\n")

        entTargetnames = []
        entClassnames  = []
        entHammerIDs   = {}

        for entIdx, ent in enumerate(self.ents.items()):
            ent = self.ents[entIdx]

            if "targetname" in ent["properties"]: entTargetnames.append(ent["properties"]["targetname"])
            entClassnames.append(ent["classname"])
            entHammerIDs[entIdx] = startID + entIdx
        
        entTargetnames = list(set(entTargetnames))
        entClassnames  = list(set(entClassnames))

        # Remove entities matching targetnames
        for targetname in entTargetnames:
            out.write(f"ent_remove_all {targetname};\n")
        
        out.write("\n")

        # Rename entities matching classnames
        for classname in entClassnames:
            out.write(f"ent_fire {classname} addoutput \"classname {classname}_old\";\n")
        
        out.write("\n")

        # Create entities
        for entIdx, ent in enumerate(self.ents.items()):
            ent = self.ents[entIdx]
            
            out.write(f"give {ent['classname']};\ntest_wait .05;\n")
            out.write(f"ent_fire {ent['classname']} addoutput \"hammerid {entHammerIDs[entIdx]}\";\ntest_wait .05;\n")
            
            for key, value in ent["properties"].items():
                out.write(f"ent_keyvalue {entHammerIDs[entIdx]} \"{key}\" \"{value}\";\n")
            
            for con in ent["connections"]:
                out.write(f"ent_keyvalue {entHammerIDs[entIdx]} \"{con['event']}\" \"{con['target']},{con['input']},{con['args']},{con['delay']}\";\n")
            
            out.write("test_wait .05;\n\n")
        